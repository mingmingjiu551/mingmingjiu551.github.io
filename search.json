[{"title":"PHP","url":"/2025/12/25/PHP/","content":"PHPphp 语法PHP 脚本可以放置在文档中的任何位置。\nPHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾：\n&lt;?php// PHP 代码写在这里?&gt;\n\nPHP 文件的默认文件扩展名是 “.php“。\nPHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。\n** 注意：**PHP 语句以分号 (;) 结尾。\n在 PHP 中，关键字（例如 if、else、while、echo 等）、类、函数和用户定义的函数不区分大小写\n但是，所有变量名都是区分大小写的！\nphp 输出在 PHP 中，有两种基本的方式来获取输出：echo 和 print。\n它们之间的区别很小：echo 没有返回值，而 print 的返回值为 1，因此它可以在表达式中使用。echo 可以接受多个参数（尽管这种用法很少见），而 print 只可接受一个参数。echo 比 print 略快一些。\necho 语句可以带括号使用，也可以不带括号使用：echo 或 echo()。\n实例\necho \"Hello\";// 等同于：echo(\"Hello\");\n\n使用双引号时，可以将变量直接插入到字符串中\n使用单引号时，必须使用 . 运算符来插入变量\n$txt1 = \"学习 PHP\";$txt2 = \"W3School.com.cn\";echo \"&lt;h2&gt;$txt1&lt;/h2&gt;\";echo \"&lt;p&gt;在 $txt2 学习 PHP&lt;/p&gt;\";\n\n$txt1 = \"学习 PHP\";$txt2 = \"W3School.com.cn\";echo '&lt;h2&gt;' . $txt1 . '&lt;/h2&gt;';echo '&lt;p&gt;在 ' . $txt2 . ' 学习 PHP&lt;/p&gt;';\n\nprint 语法和 echo 基本一样\nphp 数据类型PHP 支持以下数据类型：\n\n字符串（String）\n整数（Integer）\n浮点数（Float，也称为双精度数）\n布尔值（Boolean）\n数组（Array）\n对象（Object）\nNULL\n资源（Resource）\n\n可以使用 var_dump() 函数来获取任何对象的数据类型\nvar_dump(5);var_dump(\"Bill\");var_dump(3.14);var_dump(true);var_dump([2, 3, 56]);var_dump(NULL);\n\n字符串PHP 的 strlen() 函数返回字符串的长度\nPHP 的 str_word_count() 函数计算字符串中的单词数\nPHP 的 strpos() 函数在字符串中搜索特定文本。\n如果找到匹配项，该函数将返回第一个匹配项的字符位置。如果没有找到匹配项，它将返回 FALSE\n** 提示：** 字符串中的第一个字符位置是 0（不是 1）\n字符串的修改strtoupper() 函数将字符串返回为大写：\n$x = \"Hello World!\";echo strtoupper($x);\n\nstrtolower() 函数将字符串返回为小写：\n$x = \"Hello World!\";echo strtolower($x);\n\nPHP 的 str_replace() 函数用于在字符串中将一些字符替换为其他字符。\n将文本 “World” 替换为 “Dolly”：\n$x = \"Hello World!\";echo str_replace(\"World\", \"Dolly\", $x);\n\nPHP 的 strrev() 函数用于反转字符串。\n反转字符串 “Hello World!”：\n$x = \"Hello World!\";echo strrev($x);\n\ntrim() 可以删除开头或结尾的任何空白：\n$x = \" Hello World! \";echo trim($x);\n\nPHP 的 explode() 函数将字符串拆分为数组。\nexplode() 函数的第一个参数表示 “分隔符”。“分隔符” 指定了在哪里拆分字符串。\n** 注意：** 分隔符是必需的\n将字符串拆分为数组。使用空格字符作为分隔符：\n$x = \"Hello World!\";$y = explode(\" \", $x);\n\n字符串连接要连接或组合两个字符串，可以使用 . 运算符\n$x = \"Hello\";$y = \"World\";$z = $x . $y;echo $z;\n\n一种更简单更好的方法是利用双引号的强大功能。\n将两个变量用双引号括起来，并在它们之间留一个空格，结果中也会出现这个空格：\n$x = \"Hello\";$y = \"World\";$z = \"$x $y\";echo $z;\n\n字符串切片可以使用 substr() 函数来返回一系列字符\n请指定起始索引和想要返回的字符数。\n从索引 6 开始切片，并在 5 个位置后结束切片：\n$x = \"Hello World!\";echo substr($x, 6, 5);\n\n通过省略长度参数，范围将一直延伸到末尾\n$x = \"Hello World!\";echo substr($x, 6);\n\n从 “world” 中的 “o”（索引 -5）开始，获取 3 个字符：\n$x = \"Hello World!\";echo substr($x, -5, 3);\n\n** 注意：** 最后一个字符的索引为 -1。\n从字符串 “Hi, how are you?” 中，从索引 5 开始获取字符，并一直继续，直到到达倒数第 3 个字符（索引 -3）：\n结果应该是 “ow are y”：\n$x = \"Hi, how are you?\";echo substr($x, 5, -3);\n\n数字在 PHP 中主要有三种数字类型：\n\nInteger（整数）\nFloat（浮点数）\nNumber Strings（数字字符串）\n\n此外，PHP 还有另外两种用于数字的数据类型：\n\nInfinity（无穷大）\nNaN（非数字）\n\n整数在 32 位系统中，整数数据类型是在 -2147483648 和 2147483647 之间的非小数数，在 64 位系统中，是在 -9223372036854775808 和 9223372036854775807 之间的非小数制数。大于（或小于）此范围的值将存储为浮点数，因为它超过了整数的限制。\n** 注意：** 另一件需要知道的重要事情是，即使 4 * 2.5 等于 10，结果也被存储为浮点数，因为其中一个操作数是浮点数（2.5）。\n以下是整数的一些规则：\n\n整数必须至少有一位数字\n整数不得有小数点\n整数可以是正数或负数\n整数可以以三种格式指定：十进制（以 10 为底）、十六进制（以 16 为底 - 前缀为 0x）、八进制（以 8 为底 - 前缀为 0）或二进制（以 2 为底 - 前缀为 0b）\n\nPHP 有以下预定义的整数常量：\n\nPHP_INT_MAX - 支持的最大整数\nPHP_INT_MIN - 支持的最小整数\nPHP_INT_SIZE - 整数的大小（以字节为单位）\n\nPHP 有以下函数来检查变量的类型是否为整数：\n\nis_int()\nis_integer() - is_int () 的别名\nis_long() - is_int() 的别名\n\n浮点数浮点数数据类型通常可以存储高达 1.7976931348623E + 308 的值（取决于平台），并且具有最大 14 位数的精度。\nPHP 有以下预定义的浮点数常量（从 PHP 7.2 开始）：\n\nPHP_FLOAT_MAX - 可表示的最大浮点数\nPHP_FLOAT_MIN - 可表示的最小正浮点数\nPHP_FLOAT_DIG - 可以四舍五入为浮点数并返回而不损失精度的十进制数字的数量\nPHP_FLOAT_EPSILON - 可表示的最小正数 x，使得 x + 1.0 != 1.0\n\nPHP 有以下函数来检查变量的类型是否为浮点数：\n\nis_float()\nis_double() - is_float() 的别名\n\ninfinity大于 PHP_FLOAT_MAX 的数值被认为是无穷大（infinite）。\nPHP 有以下函数来检查数值是否是有限的或无限的：\n\nis_finite()\nis_infinite()\n\n但是，PHP 的 var_dump() 函数可返回数据类型和值：\n$x = 1.9e411;var_dump($x);结果：float(INF)\n\n类型转换在 PHP 中进行类型转换可以使用以下语句：\n\n(string) - 转换为字符串类型\n\n(int) - 转换为整数类型\n\n(float) - 转换为浮点类型\n\n(bool) - 转换为布尔类型\n如果值为 0、NULL、false 或为空，则 (bool) 会将其转换为 false，否则为 true。\n甚至 -1 也会转换为 true。\n\n(array) - 转换为数组类型\n转换为数组时，大多数数据类型都会转换为一个仅包含一个元素的索引数组。\nNULL 值会转换为一个空的数组对象。\n对象会转换为关联数组，其中属性名称成为键，属性值成为值\n\n(object) - 转换为对象类型\n转换为对象时，大多数数据类型都会转换为一个仅包含一个名为 “scalar” 的属性和相应值的对象。\nNULL 值会转换为一个空对象。\n索引数组会转换为对象，其中索引号作为属性名称，值作为属性值。\n关联数组会转换为对象，其中键作为属性名称，值作为属性值。\n\n(unset) - 转换为 NULL 类型\n\n\n数学pi() 函数返回 PI 的值\nmin() 和 max() 函数可用于查找一系列参数中的最低或最高值\nabs() 函数返回一个数的绝对值（正数）\nsqrt() 函数返回一个数的平方根\nround() 函数将浮点数四舍五入为最接近的整数\nrand() 函数生成一个随机数\necho(rand());\n\n为了更精确地控制随机数，你可以添加可选的最小值和最大值参数，以指定返回的最小整数和最大整数。\n例如，如果你想要一个介于 10 和 100（包含）之间的随机整数，请使用 rand (10, 100)\necho(rand(10, 100));\n\n常量要创建常量，请使用 define() 函数。\ndefine(name, value, case-insensitive);\n\n\nname: 指定常量的名称\nvalue: 指定常量的值\ncase-insensitive: 指定常量名称是否应不区分大小写。默认为 false。\n\n** 注意：** 在 PHP 7.3 中，定义不区分大小写的常量已被弃用。PHP 8.0 只接受 false，值 true 将产生警告。\n还可以使用 const 关键字创建常量。\n使用 const 关键字创建常量：\nconst MYCAR = \"Volvo\";echo MYCAR;\n\n\nconst 始终区分大小写。\ndefine() 具有不区分大小写的选项。\nconst 不能在另一个块作用域内创建，例如在函数内部或 if 语句内部。\ndefine 可以在另一个块作用域内创建。\n\n从 PHP7 开始，可以使用 define() 函数创建一个数组常量\ndefine(\"cars\", [  \"Volvo\",  \"BMW\",  \"BYD\"]);echo cars[0];\n\n运算符\n\n\n===\n全等\n$x === $y\n如果 $x 等于 $y，且它们类型相同，则返回 true。\n\n\n\n&lt;&gt;\n不等于\n$x &lt;&gt; $y\n如果 $x 不等于 $y，则返回 true。\n\n\n\n\n\n!==\n不全等\n$x !== $y\n如果 $x 不等于 $y，或它们类型不同，则返回 true。\n\n\n\n&lt;=&gt;\n太空船运算符\n$x &lt;=&gt; $y\n根据 $x 是小于、等于或大于 $y，分别返回一个小于、等于或大于 0 的整数。在 PHP 7 中引入\n\n\n\n\n\n?:\n三元运算符\n$x = expr1 ? expr2 : expr3\n返回 $x 的值。如果 expr1 为 TRUE，则 $x 的值为 expr2。如果 expr1 为 FALSE，则 $x 的值为 expr3。\n\n\n\n??\n空合并运算符\n$x = expr1 ?? expr2\n返回 $x 的值。如果 expr1 存在且不为 NULL，则 $x 的值为 expr1。如果 expr1 不存在或为 NULL，则 $x 的值为 expr2。在 PHP 7 中引入。\n\n\n循环foreach 循环 - 针对数组中的每个元素或对象中的每个属性循环代码块。\nforeach 循环最常见的用途是循环遍历数组的元素。\n循环遍历索引数组的元素：\n$colors = array(\"red\", \"green\", \"blue\", \"yellow\");foreach ($colors as $x) {  echo \"$x &lt;br&gt;\";}\n\n上面的数组是一个索引数组，其中第一个元素的键为 0，第二个元素的键为 1，依此类推。\n关联数组则不同，关联数组使用您为其分配的命名键，并且在循环遍历关联数组时，您可能希望同时保留键和值。\n这可以通过在 foreach 定义中同时指定键和值来完成\n打印 $members 数组中的键和值：\n$members = array(\"Bill\"=&gt;\"35\", \"Steve\"=&gt;\"37\", \"Elon\"=&gt;\"43\");foreach ($members as $x =&gt; $y) {  echo \"$x : $y &lt;br&gt;\";}\n\nforeach 循环也可以用于循环遍历对象的属性\n打印 $myCar 对象的属性名称和值：\nclass Car {  public $color;  public $model;  public function __construct($color, $model) {    $this-&gt;color = $color;    $this-&gt;model = $model;  }}$myCar = new Car(\"red\", \"Volvo\");foreach ($myCar as $x =&gt; $y) {  echo \"$x: $y &lt;br&gt;\";}\n\n在循环遍历数组元素时，默认情况下，对数组元素所做的任何更改都不会影响原始数组\n但是，通过在 foreach 声明中使用 &amp; 字符，数组元素会按引用分配，这会导致对数组元素所做的任何更改也会反映到原始数组中\n通过按引用分配数组元素，更改将影响原始数组：\n$colors = array(\"red\", \"green\", \"blue\", \"yellow\");foreach ($colors as &amp;$x) {  if ($x == \"blue\") $x = \"pink\";}var_dump($colors);\n\n函数用户定义的函数声明以关键字 function 开头，后跟函数名\nfunction myMessage() {  echo \"Hello world!\";}\n\n** 注意：** 函数名必须以字母或下划线开头。函数名不区分大小写。\n** 提示：** 请给函数一个反映函数功能的名称！\n下例显示了如何使用默认参数。如果我们调用 setHeight() 函数而不带参数，它将使用默认值作为参数\nfunction setHeight($minheight = 50) {  echo \"高度是：$minheight &lt;br&gt;\";}setHeight(350);setHeight(); // 将使用默认值 50setHeight(135);setHeight(80);\n\nPHP 中，参数通常按值传递，这意味着在函数中使用的是值的副本，并且传递给函数的变量不会被更改。\n当函数参数按引用传递时，对参数的更改也会更改传入的变量。要将函数参数转换为引用，请使用 &amp; 运算符\n使用按引用传递的参数来更新变量：\nfunction add_five(&amp;$value) {  $value += 5;}$num = 2;add_five($num);echo $num;\n\n通过在函数参数前使用 ... 运算符，函数可以接受未知数量的参数。这也称为可变参数函数。\n可变参数函数的参数会成为数组。\n你只能有一个可变长度的参数，并且它必须是最后一个参数\nfunction myFamily($lastname, ...$firstname) {  txt = \"\";  $len = count($firstname);  for($i = 0; $i &lt; $len; $i++) {    $txt = $txt.\"Hi, $firstname[$i] $lastname.&lt;br&gt;\";  }  return $txt;}$a = myFamily(\"Gates\", \"Bill\", \"Steve\", \"Elon\");echo $a;\n\nPHP 会根据变量的值自动为其关联数据类型。由于数据类型不是严格设置的，因此您可以执行诸如将字符串添加到整数之类的操作而不会引发错误。\n在 PHP 7 中，添加了类型声明。这给了我们一个选项，可以在声明函数时指定预期的数据类型，并通过添加严格声明，在数据类型不匹配时抛出 “致命错误”。\n要指定严格声明，我们需要设置 declare(strict_types=1);。这必须在 PHP 文件的第一行要指定严格声明，我们需要设置 declare(strict_types=1);。这必须在 PHP 文件的第一行\nPHP 7 还支持 return 语句的类型声明。与函数参数的类型声明一样，通过启用严格声明，在类型不匹配时将抛出 “致命错误”。\n要在函数声明中声明返回类型，请在声明函数时在左大括号 ( { ) 之前添加冒号 ( : ) 和类型。\n&lt;?php declare(strict_types=1); // 严格声明function addNumbers(float $a, float $b) : float {  return $a + $b;}echo addNumbers(1.2, 5.2);?&gt;\n\n数组数组项可以是任何数据类型。\n最常见的是字符串和数字（int, float），但数组项也可以是对象、函数或甚至是数组。\ncount() 函数用于计算数组的项数\n数组项可以是任何数据类型，包括函数。\n要执行这样的函数，请使用索引号后跟括号 ()\nfunction myFunction() {  echo \"我来自一个函数！\";}$myArr = array(\"Volvo\", 15, myFunction);$myArr[2]();\n\n更新数组项在 foreach 循环中更改项值时，有不同的技术可以使用。\n一种方法是在赋值中插入 &amp; 字符，按引用分配项值，从而确保在循环内部对数组项所做的任何更改都将应用于原始数组\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");foreach ($cars as &amp;$x) {  $x = \"Ford\";}unset($x);var_dump($cars);\n\n** 注意：** 记得在循环后添加 unset() 函数。\n如果没有 unset($x) 函数，$x 变量将保持对最后一个数组项的引用。\n添加数组项要向现有数组中添加项，可以使用括号 [] 语法。\n向 fruits 数组中添加一个项：\n$fruits = array(\"Apple\", \"Banana\", \"Cherry\");$fruits[] = \"Orange\";\n\n要向关联数组（即键 / 值数组）中添加项，请使用括号 [] 指定键，并使用 = 运算符分配值。\n向 cars 数组中添加一个项：\n$cars = array(\"brand\" =&gt; \"Ford\", \"model\" =&gt; \"Mustang\");$cars[\"color\"] = \"Red\";\n\n要向现有数组中添加多个项，请使用 array_push() 函数\n向 fruits 数组中添加三个项：\n$fruits = array(\"Apple\", \"Banana\", \"Cherry\");array_push($fruits, \"Orange\", \"Kiwi\", \"Lemon\");\n\n要向现有数组中添加多个项，您可以使用 += 运算符。\n向 cars 数组中添加两个项：\n$cars = array(\"brand\" =&gt; \"BYD\", \"model\" =&gt; \"Mustang\");$cars += [\"color\" =&gt; \"red\", \"year\" =&gt; 1964];\n\n删除数组项要从数组中删除现有项，您可以使用 array_splice() 函数。\n使用 array_splice() 函数时，您需要指定索引（从哪里开始）以及要删除的项目数量。\n删除第二项：\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");array_splice($cars, 1, 1);\n\n删除后，数组会自动重新索引，从索引 0 开始。\n还可以使用 unset() 函数来删除现有的数组项。\n注意：unset() 函数不会重新排列索引，这意味着在删除后，数组将不再包含缺失的索引。\n删除第二项：\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");unset($cars[1]);\n\nunset() 函数接受无限数量的参数，因此可用于删除多个数组项：\n删除第一项和第二项：\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");unset($cars[0], $cars[1]);\n\n还可以使用 array_diff() 函数从关联数组中删除项。\n此函数返回新数组，不包含指定的项。\n创建一个新数组，不包含 “Mustang” 和 “1964”：\n$cars = array(\"brand\" =&gt; \"Ford\", \"model\" =&gt; \"Mustang\", \"year\" =&gt; 1964);$newarray = array_diff($cars, [\"Mustang\", 1964]);\n\n注意：array_diff() 函数将值作为参数，而不是键。\narray_pop() 函数删除数组的最后一个项\n删除最后一个项：\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");array_pop($cars);\n\narray_shift() 函数删除数组的第一个项。\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");array_shift($cars);\n\n数组排序\nsort() - 对数组进行升序排序\nrsort() - 对数组进行降序排序\nasort() - 根据值对关联数组进行升序排序\nksort() - 根据键对关联数组进行升序排序\narsort() - 根据值对关联数组进行降序排序\nkrsort() - 根据键对关联数组进行降序排序\n\n下例将 $cars 数组的元素按字母顺序升序排序：\n$cars = array(\"Volvo\", \"BMW\", \"Audi\");sort($cars);\n\n其他用法同上\n超全局变量$GLOBALS要在函数内部使用全局变量，你必须使用 global 关键字将它们定义为全局的，或者使用 $GLOBALS 语法来引用它们。\n$x = 75;  function myfunction() {  echo $GLOBALS['x'];}myfunction()\n\n$x = 75;  function myfunction() {  global $x;  echo $x;}myfunction()\n\n在函数内部创建的变量仅属于该函数，但你可以使用 $GLOBALS 语法在函数内部创建全局变量\nfunction myfunction() {  $GLOBALS[\"x\"] = 100;}myfunction();echo $GLOBALS[\"x\"];echo $x;\n\n$_SERVER$_SERVER 是 PHP 中的一个超全局变量，用于存储关于头信息、路径和脚本位置的信息。\necho $_SERVER['PHP_SELF'];echo $_SERVER['SERVER_NAME'];echo $_SERVER['HTTP_HOST'];echo $_SERVER['HTTP_REFERER'];echo $_SERVER['HTTP_USER_AGENT'];echo $_SERVER['SCRIPT_NAME'];\n\n下表列出了 $_SERVER 中最重要的元素：\n\n\n\n元素 / 代码\n描述\n\n\n\n$_SERVER[‘PHP_SELF’]\n返回当前执行脚本的文件名。\n\n\n$_SERVER[‘GATEWAY_INTERFACE’]\n返回服务器使用的 Common Gateway Interface (CGI) 的版本。\n\n\n$_SERVER[‘SERVER_ADDR’]\n返回主机服务器的 IP 地址。\n\n\n$_SERVER[‘SERVER_NAME’]\n返回主机服务器的名称（如 www.w3school.com.cn）。\n\n\n$_SERVER[‘SERVER_SOFTWARE’]\n返回服务器标识字符串（如 Apache / 2.2.24）。\n\n\n$_SERVER[‘SERVER_PROTOCOL’]\n返回信息协议的名称和修订号（如 HTTP / 1.1）。\n\n\n$_SERVER[‘REQUEST_METHOD’]\n返回用于访问页面的请求方法（如 POST）。\n\n\n$_SERVER[‘REQUEST_TIME’]\n返回请求开始的时间戳（如 1377687496）。\n\n\n$_SERVER[‘QUERY_STRING’]\n如果页面是通过查询字符串访问的，则返回查询字符串。\n\n\n$_SERVER[‘HTTP_ACCEPT’]\n返回当前请求的 Accept 头。\n\n\n$_SERVER[‘HTTP_ACCEPT_CHARSET’]\n返回当前请求的 Accept_Charset 头（如 utf-8,ISO-8859-1）。\n\n\n$_SERVER[‘HTTP_HOST’]\n返回当前请求的 Host 头。\n\n\n$_SERVER[‘HTTP_REFERER’]\n返回当前页面的完整 URL（不可靠，因为不是所有用户代理都支持它）。\n\n\n$_SERVER[‘HTTPS’]\n脚本是否通过安全的 HTTP 协议查询。\n\n\n$_SERVER[‘REMOTE_ADDR’]\n返回用户查看当前页面的 IP 地址。\n\n\n$_SERVER[‘REMOTE_HOST’]\n返回用户查看当前页面的主机名。\n\n\n$_SERVER[‘REMOTE_PORT’]\n返回用户在机器上用于与 Web 服务器通信的端口。\n\n\n$_SERVER[‘SCRIPT_FILENAME’]\n返回当前执行脚本的绝对路径名。\n\n\n$_SERVER[‘SERVER_ADMIN’]\n返回在 Web 服务器配置文件中为 SERVER_ADMIN 指令给定的值。\n\n\n$_SERVER[‘SERVER_PORT’]\n返回服务器上 Web 服务器用于通信的端口（如 80）。\n\n\n$_SERVER[‘SERVER_SIGNATURE’]\n返回添加到服务器生成页面的服务器版本和虚拟主机名。\n\n\n$_SERVER[‘PATH_TRANSLATED’]\n返回当前脚本基于文件系统的路径。\n\n\n$_SERVER[‘SCRIPT_NAME’]\n返回当前脚本的路径。\n\n\n$_SERVER[‘SCRIPT_URI’]\n返回当前页面的 URI。\n\n\n"},{"title":"Hello World","url":"/2025/12/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"python","url":"/2025/12/25/python/","content":"pythonpython 列表列表常用函数![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-18 212558.png)\n元组元组定义方式：（元素，元素，元素，……）\n元组的操作方式：![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 110815.png)\n元组的注意事项：不可修改内容（可以修改内部 list 的内部元素）\n字符串字符串常用操作：![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 114608.png)\n字符串特点：![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 114929.png)\n序列哪些数据容器可视为序列列表，元组，字符串\n序列如何做切片![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 154250.png)\n集合集合的特点![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 192040.png)\n集合定义方式{元素，元素，元素，……}\n集合的常用操作![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 192304.png)\n字典字典的定义语法{key:value,key:value,key:value,……}\n空字典：\nmy_dict={}\nmy-dict=dict()\n字典的注意事项![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 193656.png)\n![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 194754.png)\n字典的常用操作总结![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 194526.png)\n数据容器特点对比![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 195744.png)\n容器通用功能![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 200719.png)\n"},{"title":"函数","url":"/2025/12/25/%E5%87%BD%E6%95%B0/","content":"函数函数返回多个返回值![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 201528.png)\n函数的多种参数使用形式![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 202657.png)\n函数作为参数传递![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 203727.png)\nlambda 匿名函数![](C:\\Users\\busho\\Pictures\\Screenshots\\ 屏幕截图 2025-12-21 204319.png)\n"}]